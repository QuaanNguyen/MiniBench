---
description: "This rule provides standards for technologies used and how to navigate the repository."
alwaysApply: true
---

# Commands

- `python -m venv .venv`: Create virtual environment (first time)
- `source .venv/bin/activate` (Linux/macOS) or `.venv\Scripts\activate` (Windows): Activate venv
- `pip install -r requirements.txt`: Install dependencies
- `uvicorn app.main:app --reload --host 0.0.0.0 --port 8000`: Run dev server
- `pytest -q`: Run tests (prefer single test files for speed: `pytest -q tests/test_streaming.py`)
- `ruff check .`: Lint
- `ruff format .`: Format
- `mypy app`: Typecheck (if configured)
- `python -m compileall app`: Quick sanity check for syntax

# Code style

- Python:
  - Target Python 3.12.
  - Prefer type hints on public functions and core modules.
  - Prefer small, testable functions over large handlers.
  - Use `logging` (no `print`) for backend diagnostics.
  - Keep I/O boundaries clear (LLM calls, sensor reads, filesystem, network).
- FastAPI:
  - Keep routers in `app/routers/` and include them in `app/main.py`.
  - Prefer `pydantic` models for request/response bodies where applicable.
  - Streaming endpoints should use SSE (`text/event-stream`) unless WebSockets are required.
- Templates (Jinja2):
  - Templates live in `app/templates/`.
  - Use `{% include %}` for reusable UI fragments (panels, tabs, metric blocks).
  - Keep logic minimal in templates; compute values in Python.
- Frontend (HTML + vanilla JS):
  - No frameworks (no React/Vue).
  - Keep JS in `app/static/js/` and load with `defer`.
  - Update DOM via `textContent`, not `innerHTML`, for streamed tokens.
  - Throttle DOM writes for streaming (buffer tokens and flush every 30–80ms).
- CSS (Pico.css):
  - Pico.css is the baseline; custom overrides go in `app/static/css/app.css`.
  - Do not add large CSS frameworks (Tailwind/Bootstrap).
  - Prefer simple layout primitives: grid, flex, minimal custom classes.

# Workflow

- After changing backend routes or streaming logic:
  - Run `ruff check .` and `pytest -q`.
  - Manually verify SSE streaming in browser (both models, both tabs).
- After changing templates/static assets:
  - Hard refresh browser (disable cache if needed).
  - Verify layout on mobile-sized viewport.
- Streaming rules (SSE):
  - Use `EventSource` on the client.
  - Server must send `Content-Type: text/event-stream`, `Cache-Control: no-cache`.
  - Emit events with clear types: `token`, `metric`, `status`, `done`, `error`.
  - Keep payloads small; batch tokens to reduce CPU and reflows.
  - Provide a cancel endpoint (POST) to stop an active job; SSE remains one-way.
- Power monitoring:
  - Sampling should be independent of token streaming (separate task/thread/process).
  - Timestamp and tag metrics per model/job for correlation.
  - Prefer fixed-rate sampling (e.g., 10–20 Hz) and aggregate server-side for UI.

# Project structure

- `app/main.py`: FastAPI app entrypoint
- `app/routers/`: API routes (including SSE endpoints)
- `app/services/`: LLM invocation, job management, power monitoring integration
- `app/templates/`: Jinja2 templates
- `app/static/js/`: Vanilla JS (SSE clients, UI behavior)
- `app/static/css/`: Pico overrides and custom CSS
- `tests/`: Pytest tests

# API conventions

- Use `/api/...` for JSON endpoints.
- Use `/sse/...` for streaming endpoints.
- Use consistent IDs: `job_id`, `model_id`.
- Always return structured errors (JSON) for non-stream endpoints.
- For SSE, send `event: error` with a short `data:` message and then close.

# Non-goals

- Do not introduce Node/npm tooling unless explicitly required.
- Do not add heavyweight client-side frameworks.
- Do not render markdown incrementally during streaming (too heavy for Pi); render plain text.
